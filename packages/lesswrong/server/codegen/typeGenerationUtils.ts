import { getCollectionName, isValidCollectionName } from '../../lib/vulcan-lib';
import { simplSchemaToGraphQLtype } from '../../lib/utils/schemaUtils';
import GraphQLJSON from 'graphql-type-json';
import SimpleSchema from 'simpl-schema'
import { print as gqlPrint } from 'graphql';
import gql from 'graphql-tag';

declare global {
  interface TypeGenerationContext {
    collections: Record<string,CollectionBase<any>>
    gqlSchemaFieldTypes: Record<string,Record<string,string>> // GQL type => field name => GQL field type
    resolverResultTypes: Record<string,string>,
  }
}

export const generatedFileHeader = `//
// GENERATED FILE
// Do not edit this file directly. Instead, start a server and run "npm run generate",
// which will cause this file to be regenerated. This file should nevertheless be
// checked in to version control.
`

export const assert = (b: boolean, message?: string) => {
  if(!b) {
    throw new Error(message || "Assertion failed");
  }
}

function typescriptMaybeNullable(type: string, nullable: boolean) {
  return nullable ? `${type} | null` : type;
}

function graphqlMaybeNullable(type: string, nullable: boolean) {
  return nullable ? type : `${type}!`;
}

export function simplSchemaTypeToTypescript(
  context: TypeGenerationContext,
  schema: SchemaType<CollectionNameString>,
  fieldName: string,
  simplSchemaType: AnyBecauseTodo,
  indent = 2,
  DbType = false,
): string {
  let nullable = !!schema[fieldName]?.nullable;
  if (DbType) {
    nullable = schema[fieldName]?.nullable !== false
  }
  if (simplSchemaType.singleType === Array) {
    const elementFieldName = `${fieldName}.$`;
    if (!(elementFieldName in schema)) {
      throw new Error(`Field ${fieldName} has an array type but ${fieldName}.$ is not in the schema`);
    }

    const typescriptStrElementType = simplSchemaTypeToTypescript(context, schema, elementFieldName, schema[elementFieldName].type);
    return `Array<${typescriptStrElementType}>`;
  } else if (simplSchemaType.singleType) {
    const allowedValues = simplSchemaType.definitions[0]?.allowedValues;
    const nullable = !!schema[fieldName]?.nullable;
    
    if (simplSchemaType.singleType === String) {
      if (allowedValues) {
        const unionType = simplSchemaUnionTypeToTypescript(allowedValues);
        return typescriptMaybeNullable(unionType, nullable);
      }
      return typescriptMaybeNullable("string", nullable);
    }
    else if (simplSchemaType.singleType === Boolean) return typescriptMaybeNullable("boolean", nullable);
    else if (simplSchemaType.singleType === Number) return typescriptMaybeNullable("number", nullable);
    else if (simplSchemaType.singleType === Date) return typescriptMaybeNullable("Date", nullable);
    else if (simplSchemaType.singleType === SimpleSchema.Integer) return typescriptMaybeNullable("number", nullable);
    
    const graphQLtype = simplSchemaToGraphQLtype(simplSchemaType.singleType, nullable);
    if (graphQLtype) {
      return graphqlTypeToTypescript(context, graphQLtype);
    } else {
      const innerSchema = simplSchemaType?.singleType?.schema?.();
      if (innerSchema) {
        const objectSchema = simplSchemaObjectTypeToTypescript(context, innerSchema, indent);
        return typescriptMaybeNullable(objectSchema, nullable);
      }
      return "any";
    }
  } else {
    return "any";
  }
  
  /*const graphqlType = simplSchemaTypeToGraphql(context, schema, fieldName, indent);
  if (!graphqlType) {
    return "any";
  }
  return graphqlTypeToTypescript(context, graphqlType);*/
}

export function simplSchemaTypeToGraphql(context: TypeGenerationContext, schema: SchemaType<CollectionNameString>, fieldName: string, indent=2): string|null {
  const simplSchemaType = schema[fieldName].type;
  
  if (simplSchemaType.singleType === Array) {
    const elementFieldName = `${fieldName}.$`;
    if (!(elementFieldName in schema)) {
      throw new Error(`Field ${fieldName} has an array type but ${fieldName}.$ is not in the schema`);
    }

    const typescriptStrElementType = simplSchemaTypeToGraphql(context, schema, elementFieldName);
    return `[${typescriptStrElementType}]`;
  } else if (simplSchemaType.singleType) {
    const allowedValues = simplSchemaType.definitions[0]?.allowedValues;
    const nullable = !!schema[fieldName]?.nullable;

    if (simplSchemaType.singleType === String) {
      if (allowedValues) {
        const unionType = simplSchemaUnionTypeToTypescript(allowedValues);
        return typescriptMaybeNullable(unionType, nullable);
      }
      return graphqlMaybeNullable("String", nullable);
    }
    else if (simplSchemaType.singleType === Boolean) return graphqlMaybeNullable("Boolean", nullable);
    else if (simplSchemaType.singleType === Number) return graphqlMaybeNullable("Float", nullable);
    else if (simplSchemaType.singleType === Date) return graphqlMaybeNullable("Date", nullable);
    else if (simplSchemaType.singleType === SimpleSchema.Integer) return graphqlMaybeNullable("Int", nullable);
    
    const graphQLtype = simplSchemaToGraphQLtype(simplSchemaType.singleType, nullable);
    if (graphQLtype) {
      return graphQLtype;
    } else {
      const innerSchema = simplSchemaType?.singleType?.schema?.();
      if (innerSchema) {
        return null; //TODO
        //const objectSchema = simplSchemaObjectTypeToGraphql(innerSchema, indent);
        //return graphqlMaybeNullable(objectSchema, nullable);
      }
      return null;
    }
  } else {
    return null;
  }
}

function simplSchemaUnionTypeToTypescript(allowedValues: string[]) {
  return allowedValues.map(allowedValue => `"${allowedValue}"`).join(" | ");
}

function simplSchemaObjectTypeToTypescript(context: TypeGenerationContext, innerSchema: AnyBecauseTodo, indent: number) {
  const indentSpaces = Array(indent + 2).fill(' ').join('');
  const fields = Object.keys(innerSchema)
    .filter((innerSchemaField) => !innerSchemaField.includes(".$")) // filter out array type definitions
    .map((innerSchemaField) => {
      const fieldTypeDef = simplSchemaTypeToTypescript(
        context,
        innerSchema,
        innerSchemaField,
        innerSchema[innerSchemaField].type,
        indent + 2
      );
      return `\n${indentSpaces}${innerSchemaField}: ${fieldTypeDef},`;
    })
    .join("");
  return `{${fields}\n${indentSpaces.slice(0, indentSpaces.length - 2)}}`;
}

function maybePartialReturnType(typeString: string, partialReturnType?: boolean) {
  if (partialReturnType) {
    return `Partial<${typeString}>`;
  }

  return typeString;
}

export function graphqlTypeToTypescript(context: TypeGenerationContext, graphqlType: any, nonnull?: boolean, partialDbReturnType?: boolean): string {
  if (!graphqlType) throw new Error("Type cannot be undefined");
  if (graphqlType === GraphQLJSON) return "any";
  
  if (graphqlType.endsWith("!")) {
    return graphqlTypeToTypescript(context, graphqlType.substr(0, graphqlType.length-1), true, partialDbReturnType);
  }
  
  if (graphqlType.startsWith("[") && graphqlType.endsWith("]")) {
    const arrayElementType = graphqlType.substr(1,graphqlType.length-2);
    return `Array<${graphqlTypeToTypescript(context, arrayElementType, false, partialDbReturnType)}>`;
  }

  const nullabilitySuffix = nonnull ? "" : "|null";
  
  const convertedPrimitiveType = graphqlPrimitiveTypeToTypescript(graphqlType, !!nonnull);
  if (convertedPrimitiveType)
    return convertedPrimitiveType;
  
  if (typeof graphqlType === "string") {
    if (isValidCollectionName(getCollectionName(graphqlType))) {
      const dbTypeString = maybePartialReturnType(`Db${graphqlType}`, partialDbReturnType);
      return `${dbTypeString}${nullabilitySuffix}`;
    } else if (context.gqlSchemaFieldTypes[graphqlType]) {
      return `${graphqlType}${nullabilitySuffix}`;
    }
  }
  
  if (graphqlType.collectionName) {
    throw new Error("wtf");
    //return graphqlType.collectionName;
  } else {
    // TODO
    //return `any /* graphqlTypeToTypescript ${graphqlType}*/`;
    return `any /*${graphqlType}*/`;
  }
}

function graphqlPrimitiveTypeToTypescript(graphqlType: string, nonnull: boolean): string|null {
  let nullableSuffix = nonnull ? "" : "|null";
  
  switch(graphqlType) {
    case "Int":     return "number" + nullableSuffix;
    case "Boolean": return "boolean" + nullableSuffix;
    case "String":  return "string" + nullableSuffix;
    case "Date":    return "Date" + nullableSuffix;
    case "Float":   return "number" + nullableSuffix;
    default:
      return null;
  }
}

export function parsedGraphqlTypeToTypescript(context: TypeGenerationContext, parsedGraphqlType: any): string {
  const gqlTypeStr = gqlPrint(parsedGraphqlType);
  return graphqlTypeToTypescript(context, gqlTypeStr);
}

