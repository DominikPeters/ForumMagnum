import CreateIndexQuery from "../../lib/sql/CreateIndexQuery";
import CreateTableQuery from "../../lib/sql/CreateTableQuery";
import PgCollection from "../../lib/sql/PgCollection";
import { getAllCollections, getCollection } from "../../lib/vulcan-lib/getCollection";
import { onConnectQueries, pgFormat } from "../sqlConnection";
import { writeFileSync } from "fs";
import { Globals } from "../vulcan-lib";
import { MIGRATION_LOG_INDEXES, MIGRATION_LOG_SCHEMA } from "../migrations/meta/PgStorage";
import { getMongo2PgLockSchema } from "../../lib/mongo2PgLock";

const getCreateTableQueryForCollection = <T extends DbObject = DbObject>(
  collection: PgCollection<T>,
): string => {
  const query = new CreateTableQuery(collection.table);
  const {sql, args} = query.compile();
  if (args.length) {
    throw new Error(`Unexpected arguments in create table query: ${args}`);
  }
  return sql + ";";
}

const getCreateIndexQueriesForCollection = <T extends DbObject = DbObject>(
  collection: PgCollection<T>,
): string[] => {
  const result: string[] = [];
  const rawIndexes = collection.table.getIndexes();
  for (const index of rawIndexes) {
    const query = new CreateIndexQuery(collection.table, index, false);
    let {sql, args} = query.compile();
    result.push(pgFormat(sql, args) + ";");
  }
  return result;
}

export const generateAtlasSchema = (filePath?: string): string => {
  let result = "";

  result += "-- THIS FILE IS GENERATED BY `yarn schema generate`\n";
  result += "-- DO NOT EDIT IT DIRECTLY\n\n";

  for (const query of onConnectQueries) {
    result += query;
    result += ";\n\n";
  }

  result += MIGRATION_LOG_SCHEMA;
  result += ";\n\n";
  for (const index of MIGRATION_LOG_INDEXES) {
    result += index;
    result += ";\n\n";
  }

  for (const query of getMongo2PgLockSchema()) {
    result += query;
    result += ";\n\n";
  }

  const collectionNames = getAllCollections().map((c) => c.collectionName).sort();
  for (const collectionName of collectionNames) {
    const collection = getCollection(collectionName);
    if (!collection) {
      throw new Error(`Invalid collection: ${collectionName}`);
    }
    if (!collection.isPostgres()) {
      continue;
    }
    collection.buildPostgresTable();

    const table = getCreateTableQueryForCollection(collection);
    result += table;
    result += "\n\n";

    const indexes = getCreateIndexQueriesForCollection(collection);
    for (const index of indexes) {
      result += index;
      result += "\n\n";
    }
  }

  if (filePath) {
    writeFileSync(filePath, result);
  }

  return result;
}

Globals.generateAtlasSchema = generateAtlasSchema;
